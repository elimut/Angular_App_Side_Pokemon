{"ast":null,"code":"import { HttpHeaders } from '@angular/common/http';\nimport { catchError, of, tap } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class AuthService {\n  // si user demande à accèder à la liste des pokemons ou autre, et qu'il n'a pas le droit demande de co, et si co ok redir au bon endroit sur la page\n  constructor(http) {\n    this.http = http;\n    this.baseURL = 'https://localhost:3000/';\n    this.isLoggedIn = false;\n  }\n  // login(name: string, password: string): Observable<boolean> {\n  //   const isLoggedIn = (name == \"pikachu\" && password =='pikachu');\n  //   // recup rst pour savoir si user auth ou non, puis délègue dans le tps d'une scd et ensuite mise à jour ppt isLoggedIn\n  //   return of(isLoggedIn).pipe\n  //     (delay(1000),\n  //     tap(isLoggedIn => this.isLoggedIn = isLoggedIn)\n  //   // simuler délai serveur\n  //     );\n  // }\n  login(name, password) {\n    const httpOptions = {\n      headers: new HttpHeaders({\n        'Content-Type': 'application/json'\n      })\n    };\n    this.isLoggedIn = true;\n    return this.http.post(this.baseURL + 'api/login', httpOptions).pipe(\n    //caste le return en Pokemon, cette méthode retourne un objet de type Pokemon\n    tap(response => this.log(response)), catchError(error => this.handleError(error, null)));\n  }\n  logout() {\n    this.isLoggedIn = false;\n  }\n  // info reste appli au niveau authService user non co\n  log(response) {\n    console.table(response);\n  }\n  handleError(error, errorValue) {\n    console.error(error);\n    return of(error, errorValue);\n    // of permet de transf une donnée simple en un flux de données = un observable qui émet la donnée en param\n  }\n}\n\nAuthService.ɵfac = function AuthService_Factory(t) {\n  return new (t || AuthService)(i0.ɵɵinject(i1.HttpClient));\n};\nAuthService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: AuthService,\n  factory: AuthService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"names":["HttpHeaders","catchError","of","tap","AuthService","constructor","http","baseURL","isLoggedIn","login","name","password","httpOptions","headers","post","pipe","response","log","error","handleError","logout","console","table","errorValue","i0","ɵɵinject","i1","HttpClient","factory","ɵfac","providedIn"],"sources":["C:\\Users\\utilisateur\\Desktop\\GIT\\Angular_App_Side_Pokemon\\src\\app\\auth.service.ts"],"sourcesContent":["import { HttpClient, HttpHeaders } from '@angular/common/http';\r\nimport { Injectable } from '@angular/core';\r\nimport { Observable, catchError, delay, of, tap } from 'rxjs';\r\nimport { User } from './user/user';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class AuthService {\r\n\r\n  private baseURL: any = 'https://localhost:3000/';\r\n  isLoggedIn: boolean = false;\r\n  // var qui dit si user est co ou non, par défaut à false, déco. Il doit prouver qu'il a les bons id\r\n  redirectUrl: string;\r\n  // si user demande à accèder à la liste des pokemons ou autre, et qu'il n'a pas le droit demande de co, et si co ok redir au bon endroit sur la page\r\n  constructor(private http: HttpClient) {}\r\n  // login(name: string, password: string): Observable<boolean> {\r\n  //   const isLoggedIn = (name == \"pikachu\" && password =='pikachu');\r\n  //   // recup rst pour savoir si user auth ou non, puis délègue dans le tps d'une scd et ensuite mise à jour ppt isLoggedIn\r\n  //   return of(isLoggedIn).pipe\r\n  //     (delay(1000),\r\n  //     tap(isLoggedIn => this.isLoggedIn = isLoggedIn)\r\n  //   // simuler délai serveur\r\n  //     );\r\n  // }\r\n  login(name: string, password: string): Observable<User> {\r\n    const httpOptions = {\r\n      headers: new HttpHeaders({ 'Content-Type': 'application/json'})\r\n    };\r\n    this.isLoggedIn = true;\r\n    return this.http.post<User>(this.baseURL+'api/login', httpOptions).pipe( //caste le return en Pokemon, cette méthode retourne un objet de type Pokemon\r\n    tap((response: any) => this.log(response)),\r\n    catchError((error: any) => this.handleError(error, null))\r\n  );\r\n  }\r\n\r\n  logout() {\r\n    this.isLoggedIn = false;\r\n  }\r\n  // info reste appli au niveau authService user non co\r\n\r\n  private log(response: any) {\r\n    console.table(response);\r\n  }\r\n\r\n  private handleError(error: Error, errorValue: any) {\r\n    console.error(error);\r\n    return of(error, errorValue);\r\n    // of permet de transf une donnée simple en un flux de données = un observable qui émet la donnée en param\r\n  }\r\n}\r\n"],"mappings":"AAAA,SAAqBA,WAAW,QAAQ,sBAAsB;AAE9D,SAAqBC,UAAU,EAASC,EAAE,EAAEC,GAAG,QAAQ,MAAM;;;AAM7D,OAAM,MAAOC,WAAW;EAMtB;EACAC,YAAoBC,IAAgB;IAAhB,KAAAA,IAAI,GAAJA,IAAI;IALhB,KAAAC,OAAO,GAAQ,yBAAyB;IAChD,KAAAC,UAAU,GAAY,KAAK;EAIY;EACvC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAC,KAAKA,CAACC,IAAY,EAAEC,QAAgB;IAClC,MAAMC,WAAW,GAAG;MAClBC,OAAO,EAAE,IAAIb,WAAW,CAAC;QAAE,cAAc,EAAE;MAAkB,CAAC;KAC/D;IACD,IAAI,CAACQ,UAAU,GAAG,IAAI;IACtB,OAAO,IAAI,CAACF,IAAI,CAACQ,IAAI,CAAO,IAAI,CAACP,OAAO,GAAC,WAAW,EAAEK,WAAW,CAAC,CAACG,IAAI;IAAE;IACzEZ,GAAG,CAAEa,QAAa,IAAK,IAAI,CAACC,GAAG,CAACD,QAAQ,CAAC,CAAC,EAC1Cf,UAAU,CAAEiB,KAAU,IAAK,IAAI,CAACC,WAAW,CAACD,KAAK,EAAE,IAAI,CAAC,CAAC,CAC1D;EACD;EAEAE,MAAMA,CAAA;IACJ,IAAI,CAACZ,UAAU,GAAG,KAAK;EACzB;EACA;EAEQS,GAAGA,CAACD,QAAa;IACvBK,OAAO,CAACC,KAAK,CAACN,QAAQ,CAAC;EACzB;EAEQG,WAAWA,CAACD,KAAY,EAAEK,UAAe;IAC/CF,OAAO,CAACH,KAAK,CAACA,KAAK,CAAC;IACpB,OAAOhB,EAAE,CAACgB,KAAK,EAAEK,UAAU,CAAC;IAC5B;EACF;;;AAzCWnB,WAAW,C;mBAAXA,WAAW,EAAAoB,EAAA,CAAAC,QAAA,CAAAC,EAAA,CAAAC,UAAA;AAAA;AAAXvB,WAAW,C;SAAXA,WAAW;EAAAwB,OAAA,EAAXxB,WAAW,CAAAyB,IAAA;EAAAC,UAAA,EAFV;AAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}