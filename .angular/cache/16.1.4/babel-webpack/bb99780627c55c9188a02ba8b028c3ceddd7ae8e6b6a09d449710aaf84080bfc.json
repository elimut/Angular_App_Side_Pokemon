{"ast":null,"code":"// import { POKEMONS } from './mock-pokemon-list';\nimport { HttpHeaders } from '@angular/common/http';\nimport { catchError, of, tap } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport class PokemonService {\n  constructor(http) {\n    this.http = http;\n    this.baseURL = 'https://localhost:3000/';\n  }\n  // getPokemonList(): Pokemon [] {\n  //   // renvoie model\n  //   return POKEMONS;\n  //   // liste des pokémons, réencapsulée dans un service pour profiter du syst d'injection de dépendance\n  // }\n  getPokemonList() {\n    // réception d'une donnée qui va arriver dans le temps qui contient un tab de pokemon, on ne retourne pas directement les pokémons. On retourne un flux\n    return this.http.get(`THIS;BASEurlapi/pokemons`).pipe(\n    // tap((pokemonList) => console.table(pokemonList)),\n    tap(response => this.log(response)),\n    // catchError((error) => {\n    //   console.log(error);\n    //   return of([]);\n    // })\n    catchError(error => this.handleError(error, [])));\n    // httpCLient d'angular par défaut renvoie des flux qui peuvent être typé, la requête get contient un tab de pokemon et on passe une URL vers une API\n    // opérateur .pipe définir ce que l'on veut faire en plus du tmt de la requête: log resp et erreurs\n    // req http get avec le client http angular et on reçoit un observable, on peut spécifier que la réponse contient une liste de pokémon. En pram de la méthode get URL, une fois qu'on a la réponse, on la log et si erreur log erreur et on retourne un tab vide\n    // opérateur rxjs tap = équivalent console log adapté à un observable, il n'intervient pas sur la requête en elle même mais on va pouvoir venir faire des op à chaque nouvelles rep\n    // catch evite l'app de crasher\n  }\n  // getPokemonById(pokemonId :number): Pokemon | undefined {\n  //   return POKEMONS.find(pokemon => pokemon.id == pokemonId);\n  // }\n  getPokemonById(pokemonId) {\n    return this.http.get(`api/pokemons/${pokemonId}`).pipe(\n    // tap((pokemon) => console.table(pokemon)),\n    tap(response => this.log(response)),\n    // catchError((error) => {\n    //   console.log(error);\n    //   return of(undefined);\n    // })\n    catchError(error => this.handleError(error, undefined)));\n  }\n  searchPokemonList(term) {\n    if (term.length <= 1) {\n      return of([]); // retourne un flux sous forme de tab vide\n    }\n\n    return this.http.get(`api/pokemons/?name=${term}`).pipe(\n    //requête sur une propriété du pokemon, ici name\n    tap(response => this.log(response)), catchError(error => this.handleError(error, [])));\n  }\n  // updatePokemon(pokemon: Pokemon): Observable<Pokemon|undefined> {\n  // travail avec null API interne\n  updatePokemon(pokemon) {\n    // ici le paramètre, le corps part dans la requête HTTP pas que dans URL. Il faut préciser au client HTTP que l'on envoie des données dans notre requête.On ajoute un header => content type application/json. En cas d'erreur on renvoie undefined\n    const httpOptions = {\n      headers: new HttpHeaders({\n        'Content-Type': 'application/json'\n      })\n    };\n    return this.http.put('api/pokemons', pokemon, httpOptions).pipe(\n    // url, corps de la requête et headers pour dire que l'on transmet tout cela en json\n    tap(response => this.log(response)),\n    // catchError((error) => this.handleError(error, undefined))\n    catchError(error => this.handleError(error, null)));\n    // put pour persister des modifications d'un objet déjà existant:\n    // .pipe ajout des tmt à l'observable\n  }\n\n  deletePokemonById(pokemonId) {\n    return this.http.delete(`api/pokemons/${pokemonId}`).pipe(tap(response => this.log(response)),\n    // catchError((error) => this.handleError(error, undefined))\n    catchError(error => this.handleError(error, null)));\n    // .pipe ajout des tmt à l'observable\n  }\n\n  addPokemon(pokemon) {\n    const httpOptions = {\n      headers: new HttpHeaders({\n        'Content-Type': 'application/json'\n      })\n    };\n    return this.http.post('api/pokemons', pokemon, httpOptions).pipe(\n    //cats le return en Pokemon, cette méthode retourne un objet de type Poemon\n    tap(response => this.log(response)), catchError(error => this.handleError(error, null)));\n  }\n  // private log(response: Pokemon[]|Pokemon|undefined) {\n  //   console.table(response);\n  // }\n  log(response) {\n    console.table(response);\n  }\n  handleError(error, errorValue) {\n    console.error(error);\n    return of(error, errorValue);\n    // of permet de transf une donnée simple en un flux de données = un observable qui émet la donnée en param\n  }\n\n  getPokemonTypeList() {\n    return ['Plante', 'Feu', 'Eau', 'Insecte', 'Normal', 'Electrik', 'Poison', 'Fée', 'Vol', 'Combat', 'Psy'];\n  }\n}\nPokemonService.ɵfac = function PokemonService_Factory(t) {\n  return new (t || PokemonService)(i0.ɵɵinject(i1.HttpClient));\n};\nPokemonService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: PokemonService,\n  factory: PokemonService.ɵfac\n});","map":{"version":3,"names":["HttpHeaders","catchError","of","tap","PokemonService","constructor","http","baseURL","getPokemonList","get","pipe","response","log","error","handleError","getPokemonById","pokemonId","undefined","searchPokemonList","term","length","updatePokemon","pokemon","httpOptions","headers","put","deletePokemonById","delete","addPokemon","post","console","table","errorValue","getPokemonTypeList","i0","ɵɵinject","i1","HttpClient","factory","ɵfac"],"sources":["C:\\Users\\utilisateur\\Desktop\\GIT\\Angular_App_Side_Pokemon\\src\\app\\pokemon\\pokemon.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\r\nimport { Pokemon } from './pokemon';\r\n// import { POKEMONS } from './mock-pokemon-list';\r\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\r\nimport { Observable, catchError, of, tap } from 'rxjs';\r\n\r\n@Injectable(\r\n  // {\r\n  // décorateur permet d'indiquer à Angular que notre service peut lui même avoir d'autres dépendances. Pour brancher ce service avec le mécanisms d'injection de dépendances d'Angular.\r\n  // providedIn: 'root'// retiré pour n'être injecté que dans le module considéré\r\n  // cette ppt indique à Angular que l'on veut utiliser la même instance du service à travers toute l'app. Nous ne créerons jamais d'instance nous même\r\n// }\r\n)\r\nexport class PokemonService {\r\n\r\n  private baseURL: string = 'https://localhost:3000/';\r\n\r\n  constructor(private http: HttpClient) {\r\n\r\n  }\r\n\r\n  // getPokemonList(): Pokemon [] {\r\n  //   // renvoie model\r\n  //   return POKEMONS;\r\n  //   // liste des pokémons, réencapsulée dans un service pour profiter du syst d'injection de dépendance\r\n  // }\r\n  getPokemonList(): Observable<Pokemon[]> {\r\n    // réception d'une donnée qui va arriver dans le temps qui contient un tab de pokemon, on ne retourne pas directement les pokémons. On retourne un flux\r\n    return this.http.get<Pokemon[]>(`THIS;BASEurlapi/pokemons`).pipe(\r\n        // tap((pokemonList) => console.table(pokemonList)),\r\n        tap((response) => this.log(response)),\r\n        // catchError((error) => {\r\n        //   console.log(error);\r\n        //   return of([]);\r\n        // })\r\n        catchError((error) => this.handleError(error, []))\r\n    );\r\n    // httpCLient d'angular par défaut renvoie des flux qui peuvent être typé, la requête get contient un tab de pokemon et on passe une URL vers une API\r\n    // opérateur .pipe définir ce que l'on veut faire en plus du tmt de la requête: log resp et erreurs\r\n    // req http get avec le client http angular et on reçoit un observable, on peut spécifier que la réponse contient une liste de pokémon. En pram de la méthode get URL, une fois qu'on a la réponse, on la log et si erreur log erreur et on retourne un tab vide\r\n    // opérateur rxjs tap = équivalent console log adapté à un observable, il n'intervient pas sur la requête en elle même mais on va pouvoir venir faire des op à chaque nouvelles rep\r\n    // catch evite l'app de crasher\r\n  }\r\n\r\n  // getPokemonById(pokemonId :number): Pokemon | undefined {\r\n  //   return POKEMONS.find(pokemon => pokemon.id == pokemonId);\r\n  // }\r\n  getPokemonById(pokemonId: number): Observable<Pokemon|undefined> {\r\n    return this.http.get<Pokemon>(`api/pokemons/${pokemonId}`).pipe(\r\n      // tap((pokemon) => console.table(pokemon)),\r\n      tap((response) => this.log(response)),\r\n        // catchError((error) => {\r\n        //   console.log(error);\r\n        //   return of(undefined);\r\n        // })\r\n      catchError((error) => this.handleError(error, undefined))\r\n    );\r\n  }\r\n\r\n  searchPokemonList(term: string): Observable<Pokemon[]> {\r\n    if(term.length <= 1){\r\n      return of([]);// retourne un flux sous forme de tab vide\r\n    }\r\n    return this.http.get<Pokemon[]>(`api/pokemons/?name=${term}`).pipe( //requête sur une propriété du pokemon, ici name\r\n      tap((response) => this.log(response)),\r\n      catchError((error) => this.handleError(error, []))\r\n    ); \r\n  }\r\n\r\n  // updatePokemon(pokemon: Pokemon): Observable<Pokemon|undefined> {\r\n    // travail avec null API interne\r\n  updatePokemon(pokemon: Pokemon): Observable<null> {\r\n    // ici le paramètre, le corps part dans la requête HTTP pas que dans URL. Il faut préciser au client HTTP que l'on envoie des données dans notre requête.On ajoute un header => content type application/json. En cas d'erreur on renvoie undefined\r\n    const httpOptions = {\r\n      headers: new HttpHeaders({ 'Content-Type': 'application/json'})\r\n    };\r\n\r\n    return this.http.put('api/pokemons', pokemon, httpOptions).pipe(\r\n      // url, corps de la requête et headers pour dire que l'on transmet tout cela en json\r\n      tap((response) => this.log(response)),\r\n      // catchError((error) => this.handleError(error, undefined))\r\n      catchError((error) => this.handleError(error, null))\r\n    );\r\n    // put pour persister des modifications d'un objet déjà existant:\r\n    // .pipe ajout des tmt à l'observable\r\n  }\r\n\r\n  deletePokemonById(pokemonId: number): Observable<null> {\r\n    return this.http.delete(`api/pokemons/${pokemonId}`).pipe(\r\n      tap((response) => this.log(response)),\r\n      // catchError((error) => this.handleError(error, undefined))\r\n      catchError((error) => this.handleError(error, null))\r\n    );\r\n    // .pipe ajout des tmt à l'observable\r\n  }\r\n\r\n  addPokemon(pokemon: Pokemon): Observable<Pokemon> {\r\n      const httpOptions = {\r\n        headers: new HttpHeaders({ 'Content-Type': 'application/json'})\r\n      };\r\n\r\n      return this.http.post<Pokemon>('api/pokemons', pokemon, httpOptions).pipe( //cats le return en Pokemon, cette méthode retourne un objet de type Poemon\r\n        tap((response) => this.log(response)),\r\n        catchError((error) => this.handleError(error, null))\r\n      );\r\n  }\r\n\r\n\r\n  // private log(response: Pokemon[]|Pokemon|undefined) {\r\n  //   console.table(response);\r\n  // }\r\n  private log(response: any) {\r\n    console.table(response);\r\n  }\r\n\r\n  private handleError(error: Error, errorValue: any) {\r\n    console.error(error);\r\n    return of(error, errorValue);\r\n    // of permet de transf une donnée simple en un flux de données = un observable qui émet la donnée en param\r\n  }\r\n\r\n  getPokemonTypeList(): string[] {\r\n    return [\r\n      'Plante', \r\n      'Feu', \r\n      'Eau', \r\n      'Insecte', \r\n      'Normal', \r\n      'Electrik', \r\n      'Poison', \r\n      'Fée', \r\n      'Vol', \r\n      'Combat', \r\n      'Psy'\r\n    ]; \r\n  }\r\n  \r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}